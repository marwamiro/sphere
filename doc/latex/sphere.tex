% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{sphere Documentation}
\date{January 26, 2013}
\release{0.35}
\author{Anders Damsgaard}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This is the official documentation for the \emph{sphere} discrete element modelling software. It presents the theory behind the discrete element method (DEM), the structure of the software source code, and the Python API for handling simulation setup and data analysis.

\emph{sphere} is developed by Anders Damsgaard Christensen under supervision of David Lunbek Egholm and Jan A. Piotrowski, all of the department of Geology, Aarhus University, Denmark. This document is a work in progress, and is still in an early state.

Contact: Anders Damsgaard Christensen, \href{http://cs.au.dk/~adc}{http://cs.au.dk/\textasciitilde{}adc}, \href{mailto:adc@geo.au.dk}{mailto:adc@geo.au.dk}

Contents:


\chapter{Introduction}
\label{introduction:welcome-to-sphere-s-documentation}\label{introduction:introduction}\label{introduction::doc}
The \emph{sphere}-software is used for three-dimensional discrete element method (DEM) particle simulations. The source code is written in C++, CUDA C and Python, and is compiled by the user. The main computations are performed on the graphics processing unit (GPU) using NVIDIA's general purpose parallel computing architecture, CUDA. Simulation setup and data analysis is performed with the included Python API.
The ultimate aim of the \emph{sphere} software is to simulate soft-bedded subglacial conditions, while retaining the flexibility to perform simulations of granular material in other environments.

The purpose of this documentation is to provide the user with a thorough walk-through of the installation, work-flow, data-analysis and visualization methods of \emph{sphere}. In addition, the \emph{sphere} internals are exposed to provide a way of understanding of the discrete element method numerical routines taking place.

\begin{notice}{note}{Note:}
Command examples in this document starting with the symbol \code{\$} are meant to be executed in the shell of the operational system, and \code{\textgreater{}\textgreater{}\textgreater{}} means execution in Python.
\end{notice}

All numerical values in this document, the source code, and the configuration files are typeset with strict respect to the SI unit system.


\section{Requirements}
\label{introduction:requirements}\begin{description}
\item[{The build requirements are:}] \leavevmode\begin{itemize}
\item {} 
A Nvidia CUDA-supported version of Linux or Mac OS X (see the \href{http://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html}{CUDA toolkit release notes} for more information)

\item {} 
\href{https://www.gnu.org/software/make/}{GNU Make}

\item {} 
The \href{http://gcc.gnu.org/}{GNU Compiler Collection} (GCC)

\item {} 
The \href{https://developer.nvidia.com/cuda-downloads}{Nvidia CUDA toolkit and SDK}

\end{itemize}

\item[{The runtime requirements are:}] \leavevmode\begin{itemize}
\item {} 
A \href{http://www.nvidia.com/object/cuda\_gpus.html}{CUDA-enabled GPU} with compute capability 1.1 or greater.

\item {} 
A Nvidia CUDA-enabled GPU and device driver

\end{itemize}

\item[{Optional tools, required for simulation setup and data processing:}] \leavevmode\begin{itemize}
\item {} 
\href{http://www.python.org/getit/releases/2.7/}{Python 2.7}

\item {} 
\href{http://numpy.scipy.org}{Numpy}

\item {} 
\href{http://matplotlib.org}{Matplotlib}

\item {} 
\href{http://www.imagemagick.org/script/index.php}{Imagemagick}

\item {} 
\href{http://ffmpeg.org/}{ffmpeg}

\end{itemize}

\item[{Optional tools, required for building the documentation:}] \leavevmode\begin{itemize}
\item {} 
\href{http://sphinx-doc.org}{Sphinx}
\begin{itemize}
\item {} 
\href{http://packages.python.org/sphinxcontrib-programoutput/}{sphinxcontrib-programoutput}

\end{itemize}

\item {} 
\href{http://www.stack.nl/~dimitri/doxygen/}{Doxygen}

\item {} 
\href{http://michaeljones.github.com/breathe/}{Breathe}

\item {} 
\href{http://www.nongnu.org/dvipng/}{dvipng}

\end{itemize}

\end{description}

\href{http://git-scm.com}{Git} is used as the distributed version control system platform, and the source code is maintained at \href{https://github.com/anders-dc/sphere/}{Github}. \emph{sphere} is licensed under the \href{https://www.gnu.org/licenses/gpl.html}{GNU Public License, v.3}.


\section{Building \emph{sphere}}
\label{introduction:building-sphere}
All instructions required for building \emph{sphere} are provided in a number of \code{Makefiles}. To generate the main \emph{sphere} command-line executable, go to the source code directory, and invoke GNU Make:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd src
\$ make
\end{Verbatim}

If successfull, the GNU Makefile will create the required data folders, object files, as well as the \emph{sphere} executable in the root folder. The executable will be named after the host architecture, e.g. \code{sphere\_darwin\_i386} on a 32-bit OS X system, or \code{sphere\_linux\_x86\_64} on a 64-bit linux system. Issue the following command to check the executable:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./sphere\_* --version
\end{Verbatim}

The output should look similar to this:

Command u'../../sphere\_linux\_X86\_64 --version' failed: {[}Errno 2{]} No such file or directory


The documentation can be read in the \href{http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html}{reStructuredText}-format in the \code{doc/sphinx/} folder, or build into e.g. HTML or PDF format with the following commands:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd doc/sphinx
\$ make html
\$ make latexpdf
\end{Verbatim}

To see all available output formats, execute:

\begin{Verbatim}[commandchars=\\\{\}]
\$ make help
\end{Verbatim}


\section{Work flow}
\label{introduction:work-flow}\begin{description}
\item[{After compiling the \emph{sphere} binary, the procedure of a creating and handling a simulation is typically arranged in the following order:}] \leavevmode\begin{itemize}
\item {} 
Setup of particle assemblage, physical properties and conditions using the Python API.

\item {} 
Execution of \emph{sphere} software, which simulates the particle behavior as a function of time, as a result of the conditions initially specified in the input file.

\item {} 
Inspection, analysis, interpretation and visualization of \emph{sphere} output in Python, and/or scene rendering using the built-in ray tracer.

\end{itemize}

\end{description}


\chapter{Discrete element method}
\label{dem::doc}\label{dem:discrete-element-method}
The discrete element method (or distinct element method) was initially formulated by citet\{Cundall:1979\}. It simulates the physical behavior and interaction of discrete, unbreakable particles, with their own mass and inertia, under the influence of e.g. gravity and boundary conditions such as moving walls. By discretizing time into small time steps (\$Delta t approx 10\textasciicircum{}\{-8\} si\{second\}\$), explicit integration of Newton's second law of motion is used to predict the new position and kinematic values for each particle from the previous sums of forces. This Lagrangian approach is ideal for simulating discontinuous materials, such as granularities. The complexity of the computations is kept low by representing the particles as spheres, which keeps contact-searching algorithms simple.


\chapter{Python API}
\label{python_api:module-sphere}\label{python_api::doc}\label{python_api:python-api}\index{sphere (module)}\index{Spherebin (class in sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin}\pysiglinewithargsret{\strong{class }\code{sphere.}\bfcode{Spherebin}}{\emph{np=1}, \emph{nd=3}, \emph{nw=1}, \emph{sid='unnamed'}}{}
Class containing all data SPHERE data.

Contains functions for reading and writing binaries, as well as simulation
setup and data analysis.
\index{adjustUpperWall() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.adjustUpperWall}\pysiglinewithargsret{\bfcode{adjustUpperWall}}{\emph{z\_adjust=1.1}}{}
Adjust grid and dynamic upper wall to max. particle height

\end{fulllineitems}

\index{bond() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.bond}\pysiglinewithargsret{\bfcode{bond}}{\emph{i}, \emph{j}}{}
Create a bond between particles i and j

\end{fulllineitems}

\index{bulkPorosity() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.bulkPorosity}\pysiglinewithargsret{\bfcode{bulkPorosity}}{}{}
Calculate and return the bulk porosity

\end{fulllineitems}

\index{consolidate() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.consolidate}\pysiglinewithargsret{\bfcode{consolidate}}{\emph{deviatoric\_stress=10000.0}, \emph{periodic=1}}{}
Setup consolidation experiment. Specify the upper wall 
deviatoric stress in Pascal, default value is 10 kPa.

\end{fulllineitems}

\index{defaultParams() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.defaultParams}\pysiglinewithargsret{\bfcode{defaultParams}}{\emph{mu\_s=0.4}, \emph{mu\_d=0.4}, \emph{mu\_r=0.0}, \emph{rho=2600}, \emph{k\_n=1160000000.0}, \emph{k\_t=1160000000.0}, \emph{k\_r=0}, \emph{gamma\_n=0}, \emph{gamma\_t=0}, \emph{gamma\_r=0}, \emph{gamma\_wn=10000.0}, \emph{gamma\_wt=10000.0}, \emph{capillaryCohesion=0}}{}
Initialize particle parameters to default values.
Radii must be set prior to calling this function.

\end{fulllineitems}

\index{energy() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.energy}\pysiglinewithargsret{\bfcode{energy}}{\emph{method}}{}
Calculate the sum of the energy components of all particles.

\end{fulllineitems}

\index{generateRadii() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.generateRadii}\pysiglinewithargsret{\bfcode{generateRadii}}{\emph{psd='logn'}, \emph{radius\_mean=0.00044}, \emph{radius\_variance=8.8e-09}, \emph{histogram=True}}{}
Draw random particle radii from the selected probability distribution.
Specify mean radius and variance. The variance should be kept at a
very low value.

\end{fulllineitems}

\index{initGrid() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initGrid}\pysiglinewithargsret{\bfcode{initGrid}}{}{}
Initialize grid suitable for the particle positions set previously.
The margin parameter adjusts the distance (in no. of max. radii)
from the particle boundaries.

\end{fulllineitems}

\index{initGridAndWorldsize() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initGridAndWorldsize}\pysiglinewithargsret{\bfcode{initGridAndWorldsize}}{\emph{g=array({[} 0.}, \emph{0.}, \emph{-9.80665{]})}, \emph{margin=2.0}, \emph{periodic=1}, \emph{contactmodel=2}}{}
Initialize grid suitable for the particle positions set previously.
The margin parameter adjusts the distance (in no. of max. radii)
from the particle boundaries.

\end{fulllineitems}

\index{initGridPos() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initGridPos}\pysiglinewithargsret{\bfcode{initGridPos}}{\emph{g=array({[} 0.}, \emph{0.}, \emph{-9.80665{]})}, \emph{gridnum=array({[}12}, \emph{12}, \emph{36{]})}, \emph{periodic=1}, \emph{contactmodel=2}}{}
Initialize particle positions in loose, cubic configuration.
Radii must be set beforehand.
xynum is the number of rows in both x- and y- directions.

\end{fulllineitems}

\index{initRandomGridPos() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initRandomGridPos}\pysiglinewithargsret{\bfcode{initRandomGridPos}}{\emph{g=array({[} 0.}, \emph{0.}, \emph{-9.80665{]})}, \emph{gridnum=array({[}12}, \emph{12}, \emph{32{]})}, \emph{periodic=1}, \emph{contactmodel=2}}{}
Initialize particle positions in loose, cubic configuration.
Radii must be set beforehand.
xynum is the number of rows in both x- and y- directions.

\end{fulllineitems}

\index{initRandomPos() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initRandomPos}\pysiglinewithargsret{\bfcode{initRandomPos}}{\emph{g=array({[} 0.}, \emph{0.}, \emph{-9.80665{]})}, \emph{gridnum=array({[}12}, \emph{12}, \emph{36{]})}, \emph{periodic=1}, \emph{contactmodel=2}}{}
Initialize particle positions in loose, cubic configuration.
Radii must be set beforehand.
xynum is the number of rows in both x- and y- directions.

\end{fulllineitems}

\index{initTemporal() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.initTemporal}\pysiglinewithargsret{\bfcode{initTemporal}}{\emph{total}, \emph{current=0.0}, \emph{file\_dt=0.05}, \emph{step\_count=0}}{}
Set temporal parameters for the simulation.
Particle radii and physical parameters need to be set
prior to these.

\end{fulllineitems}

\index{porosity() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.porosity}\pysiglinewithargsret{\bfcode{porosity}}{\emph{slices=10}, \emph{verbose=False}}{}
Calculate the porosity as a function of depth, by averaging values
in horizontal slabs.
Returns porosity values and depth

\end{fulllineitems}

\index{readbin() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.readbin}\pysiglinewithargsret{\bfcode{readbin}}{\emph{targetbin}, \emph{verbose=True}}{}
Reads a target SPHERE binary file

\end{fulllineitems}

\index{render() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.render}\pysiglinewithargsret{\bfcode{render}}{\emph{method='pres'}, \emph{max\_val=1000.0}, \emph{lower\_cutoff=0.0}, \emph{graphicsformat='png'}, \emph{verbose=True}}{}
Render all output files that belong to the simulation, determined by sid.

\end{fulllineitems}

\index{run() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.run}\pysiglinewithargsret{\bfcode{run}}{\emph{verbose=True}, \emph{hideinputfile=False}, \emph{dry=False}}{}
Execute sphere with target project

\end{fulllineitems}

\index{shear() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.shear}\pysiglinewithargsret{\bfcode{shear}}{\emph{shear\_strain\_rate=1}, \emph{periodic=1}}{}
Setup shear experiment. Specify the upper wall 
deviatoric stress in Pascal, default value is 10 kPa.
The shear strain rate is the shear length divided by the
initial height per second.

\end{fulllineitems}

\index{shearstrain() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.shearstrain}\pysiglinewithargsret{\bfcode{shearstrain}}{}{}
Calculates and returns the shear strain (gamma) value of the experiment

\end{fulllineitems}

\index{shearvel() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.shearvel}\pysiglinewithargsret{\bfcode{shearvel}}{}{}
Calculates and returns the shear velocity (gamma\_dot) of the experiment

\end{fulllineitems}

\index{thinsection\_x1x3() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.thinsection_x1x3}\pysiglinewithargsret{\bfcode{thinsection\_x1x3}}{\emph{x2='center'}, \emph{graphicsformat='png'}, \emph{cbmax=None}, \emph{arrowscale=0.01}, \emph{slipscale=1.0}, \emph{verbose=False}}{}
Produce a 2D image of particles on a x1,x3 plane, intersecting the second axis at x2.
Output is saved as `\textless{}sid\textgreater{}-ts-x1x3.txt' in the current folder.

An upper limit to the pressure color bar range can be set by the cbmax parameter.
\begin{description}
\item[{The data can be plotted in gnuplot with:}] \leavevmode
gnuplot\textgreater{} set size ratio -1
gnuplot\textgreater{} set palette defined (0 ``blue'', 0.5 ``gray'', 1 ``red'')
gnuplot\textgreater{} plot `\textless{}sid\textgreater{}-ts-x1x3.txt' with circles palette fs transparent solid 0.4 noborder

\end{description}

\end{fulllineitems}

\index{torqueScript() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.torqueScript}\pysiglinewithargsret{\bfcode{torqueScript}}{\emph{email='adc@geo.au.dk'}, \emph{email\_alerts='ae'}, \emph{walltime=`8:00:00'}}{}
Create job script for the Torque queue manager for the binary

\end{fulllineitems}

\index{uniaxialStrainRate() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.uniaxialStrainRate}\pysiglinewithargsret{\bfcode{uniaxialStrainRate}}{\emph{wvel=-0.001}, \emph{periodic=1}}{}
Setup consolidation experiment. Specify the upper wall 
velocity in m/s, default value is -0.001 m/s (i.e. downwards).

\end{fulllineitems}

\index{voidRatio() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.voidRatio}\pysiglinewithargsret{\bfcode{voidRatio}}{}{}
Returns the current void ratio

\end{fulllineitems}

\index{writebin() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.writebin}\pysiglinewithargsret{\bfcode{writebin}}{\emph{folder='../input/'}, \emph{verbose=True}}{}
Writes to a target SPHERE binary file

\end{fulllineitems}

\index{zeroKinematics() (sphere.Spherebin method)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.Spherebin.zeroKinematics}\pysiglinewithargsret{\bfcode{zeroKinematics}}{}{}
Zero kinematics of particles

\end{fulllineitems}


\end{fulllineitems}

\index{V\_sphere() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.V_sphere}\pysiglinewithargsret{\code{sphere.}\bfcode{V\_sphere}}{\emph{r}}{}
Returns the volume of a sphere with radius r

\end{fulllineitems}

\index{convert() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.convert}\pysiglinewithargsret{\code{sphere.}\bfcode{convert}}{\emph{graphicsformat='png'}, \emph{folder='../img\_out'}}{}
Converts all PPM images in img\_out to graphicsformat, using ImageMagick

\end{fulllineitems}

\index{render() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.render}\pysiglinewithargsret{\code{sphere.}\bfcode{render}}{\emph{binary}, \emph{method='pres'}, \emph{max\_val=1000.0}, \emph{lower\_cutoff=0.0}, \emph{graphicsformat='png'}, \emph{verbose=True}}{}
Render target binary using the sphere raytracer.

\end{fulllineitems}

\index{run() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.run}\pysiglinewithargsret{\code{sphere.}\bfcode{run}}{\emph{binary}, \emph{verbose=True}, \emph{hideinputfile=False}}{}
Execute sphere with target binary as input

\end{fulllineitems}

\index{status() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.status}\pysiglinewithargsret{\code{sphere.}\bfcode{status}}{\emph{project}}{}
Check the status.dat file for the target project,
and return the last file numer.

\end{fulllineitems}

\index{thinsectionVideo() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.thinsectionVideo}\pysiglinewithargsret{\code{sphere.}\bfcode{thinsectionVideo}}{\emph{project}, \emph{out\_folder='./'}, \emph{video\_format='mp4'}, \emph{fps=25}, \emph{qscale=1}, \emph{bitrate=1800}, \emph{verbose=False}}{}
Use ffmpeg to combine thin section images to animation.
This function will start off by rendering the images.

\end{fulllineitems}

\index{video() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.video}\pysiglinewithargsret{\code{sphere.}\bfcode{video}}{\emph{project}, \emph{out\_folder='./'}, \emph{video\_format='mp4'}, \emph{graphics\_folder='../img\_out/'}, \emph{graphics\_format='png'}, \emph{fps=25}, \emph{qscale=1}, \emph{bitrate=1800}, \emph{verbose=False}}{}
Use ffmpeg to combine images to animation. All images should be rendered beforehand.

\end{fulllineitems}

\index{visualize() (in module sphere)}

\begin{fulllineitems}
\phantomsection\label{python_api:sphere.visualize}\pysiglinewithargsret{\code{sphere.}\bfcode{visualize}}{\emph{project}, \emph{method='energy'}, \emph{savefig=True}, \emph{outformat='png'}}{}
Visualize output from the target project,
where the temporal progress is of interest.

\end{fulllineitems}



\chapter{sphere internals}
\label{sphere_internals:sphere-internals}\label{sphere_internals::doc}
The \emph{sphere} executable has the following options:

Command u'../../sphere\_linux\_X86\_64 --help' failed: {[}Errno 2{]} No such file or directory


The most common way to invoke \emph{sphere} is however via the Python API (e.g. {\hyperref[python_api:sphere.run]{\code{sphere.run()}}}, {\hyperref[python_api:sphere.render]{\code{sphere.render()}}}, etc.).

subsection\{The \emph{sphere} algorithm\}
label\{subsec:spherealgo\}
The \emph{sphere}-binary is launched from the system terminal by passing the simulation ID as an input parameter; texttt\{./sphere\_\textless{}architecture\textgreater{} \textless{}simulation\_ID\textgreater{}\}. The sequence of events in the program is the following:
\#. System check, including search for NVIDIA CUDA compatible devices (texttt\{main.cpp\}).
\begin{enumerate}
\item {} 
Initial data import from binary input file (texttt\{main.cpp\}).

\item {} 
Allocation of memory for all host variables (particles, grid, walls, etc.) (texttt\{main.cpp\}).

\item {} 
Continued import from binary input file (texttt\{main.cpp\}).

\item {} 
Control handed to GPU-specific function texttt\{gpuMain(ldots)\} (texttt\{device.cu\}).

\item {} 
Memory allocation of device memory (texttt\{device.cu\}).

\item {} 
Transfer of data from host to device variables (texttt\{device.cu\}).

\item {} 
Initialization of Thrustfootnote\{url\{\href{https://code.google.com/p/thrust/}{https://code.google.com/p/thrust/}\}\} radix sort configuration (texttt\{device.cu\}).

\item {} 
Calculation of GPU workload configuration (thread and block layout) (texttt\{device.cu\}).

\item {} 
Status and data written to verb''\textless{}simulation\_ID\textgreater{}.status.dat'' and verb''\textless{}simulation\_ID\textgreater{}.output0.bin'', both located in texttt\{output/\} folder (texttt\{device.cu\}).

\item {} 
Main loop (while texttt\{time.current \textless{}= time.total\}) (functions called in texttt\{device.cu\}, function definitions in seperate files). Each kernel call is wrapped in profiling- and error exception handling functions:

\end{enumerate}
\begin{enumerate}
\item {} 
label\{loopstart\}CUDA thread synchronization point.

\item {} 
texttt\{calcParticleCellID\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Particle-grid hash value calculation (texttt\{sorting.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{thrust::sort\_by\_key(ldots)\}: Thrust radix sort of particle-grid hash array (texttt\{device.cu\}).

\item {} 
texttt\{cudaMemset(ldots)\}: Writing zero value (texttt\{0xffffffff\}) to empty grid cells (texttt\{device.cu\}).

\item {} 
texttt\{reorderArrays\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Reordering of particle arrays, based on sorted particle-grid-hash values (texttt\{sorting.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
Optional: texttt\{topology\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: If particle contact history is required by the contact model, particle contacts are identified, and stored per particle. Previous, now non-existant contacts are discarded (texttt\{contactsearch.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{interact\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: For each particle: Search of contacts in neighbor cells, processing of optional collisions and updating of resulting forces and torques. Values are written to read/write device memory arrays (texttt\{contactsearch.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{integrate\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Updating of spatial degrees of freedom by a second-order Taylor series expansion integration (texttt\{integration.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{summation\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Particle contributions to the net force on the walls are summated (texttt\{integration.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{integrateWalls\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Updating of spatial degrees of freedom of walls (texttt\{integration.cuh\}).

\item {} 
Update of timers and loop-related counters (e.g. texttt\{time.current\}), (texttt\{device.cu\}).

\item {} 
If file output interval is reached:
\begin{quote}
\begin{quote}

item Optional write of data to output binary (verb''\textless{}simulation\_ID\textgreater{}.output\#..bin''), (texttt\{file\_io.cpp\}).
item Update of verb''\textless{}simulation\_ID\textgreater{}.status\#..bin'' (texttt\{device.cu\}).
\end{quote}

item Return to point ref\{loopstart\}, unless texttt\{time.current \textgreater{}= time.total\}, in which case the program continues to point ref\{loopend\}.
\end{quote}

\end{enumerate}
\begin{enumerate}
\item {} 
label\{loopend\}Liberation of device memory (texttt\{device.cu\}).

\item {} 
Control returned to texttt\{main(ldots)\}, liberation of host memory (texttt\{main.cpp\}).

\item {} 
End of program, return status equal to zero (0) if no problems where encountered.

\end{enumerate}


\section{Numerical algorithm}
\label{sphere_internals:numerical-algorithm}
The \emph{sphere}-binary is launched from the system terminal by passing the simulation ID as an input parameter; texttt\{./sphere\_\textless{}architecture\textgreater{} \textless{}simulation\_ID\textgreater{}\}. The sequence of events in the program is the following:
\begin{enumerate}
\item {} 
System check, including search for NVIDIA CUDA compatible devices (texttt\{main.cpp\}).

\item {} 
Initial data import from binary input file (texttt\{main.cpp\}).

\item {} 
Allocation of memory for all host variables (particles, grid, walls, etc.) (texttt\{main.cpp\}).

\item {} 
Continued import from binary input file (texttt\{main.cpp\}).

\item {} 
Control handed to GPU-specific function texttt\{gpuMain(ldots)\} (texttt\{device.cu\}).

\item {} 
Memory allocation of device memory (texttt\{device.cu\}).

\item {} 
Transfer of data from host to device variables (texttt\{device.cu\}).

\item {} 
Initialization of Thrustfootnote\{url\{\href{https://code.google.com/p/thrust/}{https://code.google.com/p/thrust/}\}\} radix sort configuration (texttt\{device.cu\}).

\item {} 
Calculation of GPU workload configuration (thread and block layout) (texttt\{device.cu\}).

\item {} 
Status and data written to verb''\textless{}simulation\_ID\textgreater{}.status.dat'' and verb''\textless{}simulation\_ID\textgreater{}.output0.bin'', both located in texttt\{output/\} folder (texttt\{device.cu\}).

\item {} 
Main loop (while texttt\{time.current \textless{}= time.total\}) (functions called in texttt\{device.cu\}, function definitions in seperate files). Each kernel call is wrapped in profiling- and error exception handling functions:

\end{enumerate}
\begin{enumerate}
\item {} 
label\{loopstart\}CUDA thread synchronization point.

\item {} 
texttt\{calcParticleCellID\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Particle-grid hash value calculation (texttt\{sorting.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{thrust::sort\_by\_key(ldots)\}: Thrust radix sort of particle-grid hash array (texttt\{device.cu\}).

\item {} 
texttt\{cudaMemset(ldots)\}: Writing zero value (texttt\{0xffffffff\}) to empty grid cells (texttt\{device.cu\}).

\item {} 
texttt\{reorderArrays\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Reordering of particle arrays, based on sorted particle-grid-hash values (texttt\{sorting.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
Optional: texttt\{topology\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: If particle contact history is required by the contact model, particle contacts are identified, and stored per particle. Previous, now non-existant contacts are discarded (texttt\{contactsearch.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{interact\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: For each particle: Search of contacts in neighbor cells, processing of optional collisions and updating of resulting forces and torques. Values are written to read/write device memory arrays (texttt\{contactsearch.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{integrate\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Updating of spatial degrees of freedom by a second-order Taylor series expansion integration (texttt\{integration.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{summation\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Particle contributions to the net force on the walls are summated (texttt\{integration.cuh\}).

\item {} 
CUDA thread synchronization point.

\item {} 
texttt\{integrateWalls\textless{}\textless{}\textless{},\textgreater{}\textgreater{}\textgreater{}(ldots)\}: Updating of spatial degrees of freedom of walls (texttt\{integration.cuh\}).

\item {} 
Update of timers and loop-related counters (e.g. texttt\{time.current\}), (texttt\{device.cu\}).

\item {} 
If file output interval is reached:
\begin{itemize}
\item {} 
Optional write of data to output binary (verb''\textless{}simulation\_ID\textgreater{}.output\#..bin''), (texttt\{file\_io.cpp\}).

\item {} 
Update of verb''\textless{}simulation\_ID\textgreater{}.status\#..bin'' (texttt\{device.cu\}).

\end{itemize}

\item {} 
Return to point ref\{loopstart\}, unless texttt\{time.current \textgreater{}= time.total\}, in which case the program continues to point ref\{loopend\}.

\end{enumerate}
\begin{enumerate}
\item {} 
label\{loopend\}Liberation of device memory (texttt\{device.cu\}).

\item {} 
Control returned to texttt\{main(ldots)\}, liberation of host memory (texttt\{main.cpp\}).

\item {} 
End of program, return status equal to zero (0) if no problems where encountered.

\end{enumerate}

The length of the computational time steps (texttt\{time.dt\}) is calculated via equation ref\{eq:dt\}, where length of the time intervals is defined by:
\begin{gather}
\begin{split}\Delta t = 0.075 \min \left( m/\max(k_n,k_t) \right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
where $m$ is the particle mass, and $k$ are the elastic stiffnesses.
The time step is set by this relationship in \code{initTemporal()}.
This equation ensures that the elastic wave (traveling at the speed of sound) is resolved a number of times while traveling through the smallest particle.

subsubsection\{Host and device memory types\}
label\{subsubsec:memorytypes\}
A full, listed description of the \emph{sphere} source code variables can be found in appendix ref\{apx:SourceCodeVariables\}, page pageref\{apx:SourceCodeVariables\}. There are three types of memory types employed in the \emph{sphere} source code, with different characteristics and physical placement in the system (figure ref\{fig:memory\}).

The floating point precision operating internally in \emph{sphere} is defined in texttt\{datatypes.h\}, and can be either single (texttt\{float\}), or double (texttt\{double\}). Depending on the GPU, the calculations are performed about double as fast in single precision, in relation to double precision. In dense granular configuraions, the double precision however results in greatly improved numerical stability, and is thus set as the default floating point precision. The floating point precision is stored as the type definitions texttt\{Float\}, texttt\{Float3\} and texttt\{Float4\}. The floating point values in the in- and output datafiles are emph\{always\} written in double precision, and, if necessary, automatically converted by \emph{sphere}.

Three-dimensional variables (e.g. spatial vectors in \emph{E\textasciicircum{}3}) are in global memory stored as texttt\{Float4\} arrays, since these read and writes can be coalesced, while e.g. texttt\{float3\}'s cannot. This alone yields a \emph{sim{}`20}times{}` performance boost, even though it involves 25\% more (unused) data.

paragraph\{Host memory\} is the main random-access computer memory (RAM), i.e. read and write memory accessible by CPU processes, but inaccessible by CUDA kernels executed on the device.

paragraph\{Device memory\} is the main, global device memory. It resides off-chip on the GPU, often in the form of 1--6 GB DRAM. The read/write access from the CUDA kernels is relatively slow. The arrays residing in (global) device memory are prefixed by \code{dev\_} in the source code.

marginpar\{Todo: Expand section on device memory types\}

paragraph\{Constant memory\} values cannot be changed after they are set, and are used for scalars or small vectors. Values are set in the \code{transferToConstantMemory(...)\}} function, called in the beginning of texttt\{gpuMain(ldots)\} in texttt\{device.cu\}. Constant memory variables have a global scope, and are prefixed by \code{devC\_} in the source code.

\%subsection\{The main loop\}
\%label\{subsec:mainloop\}
\%The \emph{sphere} software calculates particle movement and rotation based on the forces applied to it, by application of Newton's law of motion (Newton's second law with constant particle mass: \emph{F\_\{mathrm\{net\}\} = mÂ cdot a\_\{mathrm\{cm\}\}}). This is done in a series of algorithmic steps, see list on page pageref\{loopstart\}. The steps are explained in the following sections with reference to the \emph{sphere}-source file; texttt\{sphere.cu\}. The intent with this document is emph\{not\} to give a full theoretical background of the methods, but rather how the software performs the calculations.

subsection\{Performance\}
marginpar\{Todo: insert graph of performance vs. np and performance vs. \emph{Delta t}\}.
subsubsection\{Particles and computational time\}

subsection\{Compilation\}
label\{subsec:compilation\}
An important note is that the texttt\{C\} examples of the NVIDIA CUDA SDK should be compiled before \emph{sphere}. Consult the \emph{Getting started guide}, supplied by Nvidia for details on this step.

\emph{sphere} is supplied with several Makefiles, which automate the compilation process. To compile all components, open a shell, go to the texttt\{src/\} subfolder and type texttt\{make\}. The GNU Make will return the parameters passed to the individual CUDA and GNU compilers (texttt\{nvcc\} and texttt\{gcc\}). The resulting binary file (texttt\{sphere\}) is placed in the \emph{sphere} root folder. \code{src/Makefile} will also compile the raytracer.


\section{C++ reference}
\label{sphere_internals:c-reference}\phantomsection\label{sphere_internals:project0classDEM}\phantomsection\label{sphere_internals:project0classDEM}
\begin{DUlineblock}{0em}
\item[] \emph{class} \textbf{DEM}
\end{DUlineblock}
\begin{quote}




\emph{Public Functions}\begin{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a3cd6355aefc172c712f1c91f4ffc36f2}\phantomsection\label{sphere_internals:project0classDEM_1a3cd6355aefc172c712f1c91f4ffc36f2}
\begin{DUlineblock}{0em}
\item[]  \textbf{DEM}(std::string inputbin, const int verbosity = 1, const int checkVals = 1, const int dry = 0, const int initCuda = 1, const int transferConstMem = 1)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1aa3066aa501f982c2df51f58fb5a91148}\phantomsection\label{sphere_internals:project0classDEM_1aa3066aa501f982c2df51f58fb5a91148}
\begin{DUlineblock}{0em}
\item[]  \textbf{\textasciitilde{}DEM}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ac32ef9094b25ee9c35e30f4488491fe2}\phantomsection\label{sphere_internals:project0classDEM_1ac32ef9094b25ee9c35e30f4488491fe2}
\begin{DUlineblock}{0em}
\item[] void \textbf{readbin}(const char * target)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a242634f10a9bc1f19e4eb46b7168f288}\phantomsection\label{sphere_internals:project0classDEM_1a242634f10a9bc1f19e4eb46b7168f288}
\begin{DUlineblock}{0em}
\item[] void \textbf{writebin}(const char * target)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a101aafa4f3197948fafbb1500e58f0f5}\phantomsection\label{sphere_internals:project0classDEM_1a101aafa4f3197948fafbb1500e58f0f5}
\begin{DUlineblock}{0em}
\item[] void \textbf{checkValues}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ae2a1e6696686617f9cbe05b1a264212d}\phantomsection\label{sphere_internals:project0classDEM_1ae2a1e6696686617f9cbe05b1a264212d}
\begin{DUlineblock}{0em}
\item[] void \textbf{reportValues}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a870787f68a947706aac1960e5cc1eda8}\phantomsection\label{sphere_internals:project0classDEM_1a870787f68a947706aac1960e5cc1eda8}
\begin{DUlineblock}{0em}
\item[] void \textbf{startTime}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ab28a7813c5848d3b27e6f1ed5196d649}\phantomsection\label{sphere_internals:project0classDEM_1ab28a7813c5848d3b27e6f1ed5196d649}
\begin{DUlineblock}{0em}
\item[] void \textbf{render}(const int method = 1, const float maxval = 1.0e3f, const float lower\_cutoff = 0.0f, const float focalLength = 1.0f, const unsigned int img\_width = 800, const unsigned int img\_height = 800)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a5abc32b3691e7336e80cfab162d0a237}\phantomsection\label{sphere_internals:project0classDEM_1a5abc32b3691e7336e80cfab162d0a237}
\begin{DUlineblock}{0em}
\item[] void \textbf{writePPM}(const char * target)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ad4e191a3aa8491ae04f1897ff1f24bde}\phantomsection\label{sphere_internals:project0classDEM_1ad4e191a3aa8491ae04f1897ff1f24bde}
\begin{DUlineblock}{0em}
\item[] void \textbf{porosity}(const int z\_slices = 10)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ad686ac121d845e804515bcf7209b9f71}\phantomsection\label{sphere_internals:project0classDEM_1ad686ac121d845e804515bcf7209b9f71}
\begin{DUlineblock}{0em}
\item[] Float3 \textbf{minPos}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1ab6c76ee881de3d710fe1fdcb3ca46dfc}\phantomsection\label{sphere_internals:project0classDEM_1ab6c76ee881de3d710fe1fdcb3ca46dfc}
\begin{DUlineblock}{0em}
\item[] Float3 \textbf{maxPos}(void)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a9fa9b39cf7f038cc961337f9d4e162e5}\phantomsection\label{sphere_internals:project0classDEM_1a9fa9b39cf7f038cc961337f9d4e162e5}
\begin{DUlineblock}{0em}
\item[] void \textbf{findOverlaps}(std::vector\textless{} std::vector\textless{} unsigned int \textgreater{} \textgreater{} \& ij, std::vector\textless{} Float \textgreater{} \& delta\_n\_ij)
\end{DUlineblock}

\begin{quote}






\end{quote}

\phantomsection\label{sphere_internals:project0classDEM_1a0cb0fcf60594f664a9e593917c623767}\phantomsection\label{sphere_internals:project0classDEM_1a0cb0fcf60594f664a9e593917c623767}
\begin{DUlineblock}{0em}
\item[] void \textbf{forcechains}(const std::string format = ``interactive'', const int threedim = 1)
\end{DUlineblock}

\begin{quote}






\end{quote}
\end{quote}
\end{quote}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\texttt{sphere}}, \pageref{python_api:module-sphere}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
